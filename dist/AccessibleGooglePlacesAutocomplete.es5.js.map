{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/AccessibleGooglePlacesAutocomplete.tsx","webpack:///external \"react\"","webpack:///external \"react-load-script\"","webpack:///external \"accessible-autocomplete/react\"","webpack:///./src/translate.ts","webpack:///external \"get-value\"","webpack:///./src/parseUnitNumber.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","React","Script","react_1","translate_1","parseUnitNumber_1","AccessibleGooglePlacesAutocomplete","_super","props","_this","this","onAutoCompleteSelect","__awaiter","_a","_b","useMoreAccuratePostalCode","_c","onError","_d","onConfirm","placeId","formattedPredictionsMap","undefined","selectedPrediction","predictions","find","prediction","place_id","getPlaceDetails","placeResult","_e","sent","hasPartialPostalCode","address_components","getReverseGeocodeData","geocodeResult","filter","component","types","includes","concat","unitDesignator","unitNumber","designatorMap","fl","rm","push","long_name","short_name","hasPlaceSelected","placesSessionToken","google","maps","places","AutocompleteSessionToken","e_1","state","apiLoaded","currentStatusMessage","onApiLoad","getSuggestions","getNoResultsMessage","getStatusResultsMessage","getStatusSelectedOptionMessage","getStatusNoResultsMessage","__extends","setState","autocompleteService","AutocompleteService","geocoderService","Geocoder","placesService","PlacesService","document","createElement","translate","selectedOption","option","statusNoResults","length","contentSelectedOption","statusResults","smart_count","query","populateResults","googlePlacesOptions","minLength","onClear","unitDesignators","parseUnitNumber","civicAddress","request","__assign","input","sessionToken","getPlacePredictions","status","PlacesServiceStatus","OK","reduce","accumulator","formatPrediction","description","results","keys","render","autoselect","googlePlacesApiKey","id","required","googlePlacesApi","encodeURIComponent","aria-live","style","visibility","url","onLoad","default","source","displayMenu","tNoResults","tStatusSelectedOption","tStatusNoResults","tStatusResults","unitAddress","replace","addressComponents","Promise","reject","resolve","getDetails","requestStatus","place","geocode","location","geometry","geocodeStatus","GeocoderStatus","bestResult","result","map","fieldName","isAddressMatch","isFieldMatch","Component","DEFAULT_UNIT_DESIGNATORS","DEFAULT_DESIGNATORS","require","message","context","translation","addressAutoComplete","noResults","statusSelectedOption","split","trim","match","contextKey","#","apartment","building","department","floor","hanger","lot","pier","room","slip","space","stop","suite","trailer","unit","unitNumberExp","normalizeUnitNumber","toUpperCase","normalizeDesignator","designator","strippedDesignator","toLocaleLowerCase","designators","current","join","buildDesignatorExpression","dashedMatches","exec","dashedLetterMatches","afterNumberMatches","RegExp","afterStreetMatches","civicAddressPart1","civicAddressPart2","beforeCivicNumberMatches"],"mappings":"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","file":"AccessibleGooglePlacesAutocomplete.es5.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import * as React from 'react';\nimport * as Script from 'react-load-script';\nimport Autocomplete from 'accessible-autocomplete/react';\nimport { translate } from './translate';\nimport { DEFAULT_DESIGNATORS, parseUnitNumber } from './parseUnitNumber';\n\nconst DEFAULT_MIN_LENGTH = 4;\n\ninterface IAccessibleGooglePlacesAutocompleteOptions {\n  bounds?: google.maps.LatLngBounds | google.maps.LatLngBoundsLiteral;\n  componentRestrictions?: google.maps.places.ComponentRestrictions;\n  location?: google.maps.LatLng;\n  offset?: number;\n  radius?: number;\n  types?: string[];\n}\n\ninterface IAccessibleGooglePlacesAutocompleteProps {\n  autoselect?: boolean;\n  googlePlacesApiKey: string;\n  googlePlacesOptions?: IAccessibleGooglePlacesAutocompleteOptions;\n  id: string;\n  minLength?: number;\n  onClear?: () => void;\n  onConfirm?: (placeResult: google.maps.places.PlaceResult) => void;\n  onError?: (error: any) => void;\n  required?: boolean;\n  t?: any;\n  unitDesignators?: Record<string, string>;\n  useMoreAccuratePostalCode?: boolean;\n}\n\ninterface IAccessibleGooglePlacesAutocompleteState {\n  apiLoaded: boolean;\n}\n\nexport class AccessibleGooglePlacesAutocomplete extends React.Component<\n  IAccessibleGooglePlacesAutocompleteProps,\n  IAccessibleGooglePlacesAutocompleteState\n> {\n  private geocoderService?: google.maps.Geocoder;\n  private autocompleteService?: google.maps.places.AutocompleteService;\n  private placesService?: google.maps.places.PlacesService;\n  private placesSessionToken: google.maps.places.AutocompleteSessionToken;\n  private predictions: google.maps.places.AutocompletePrediction[];\n  private currentStatusMessage: string;\n  private formattedPredictionsMap: Record<string, string>;\n  private hasPlaceSelected: boolean;\n  private unitDesignator: string;\n  private unitNumber: string;\n\n  constructor(props: IAccessibleGooglePlacesAutocompleteProps) {\n    super(props);\n\n    this.state = {\n      apiLoaded: false\n    };\n\n    this.formattedPredictionsMap = {};\n    this.predictions = [];\n    this.unitDesignator = '';\n    this.unitNumber = '';\n    this.currentStatusMessage = '';\n\n    this.onApiLoad = this.onApiLoad.bind(this);\n    this.getSuggestions = this.getSuggestions.bind(this);\n    this.getNoResultsMessage = this.getNoResultsMessage.bind(this);\n    this.getStatusResultsMessage = this.getStatusResultsMessage.bind(this);\n    this.getStatusSelectedOptionMessage = this.getStatusSelectedOptionMessage.bind(\n      this\n    );\n    this.getStatusNoResultsMessage = this.getStatusNoResultsMessage.bind(this);\n  }\n\n  public onAutoCompleteSelect = async (value: string) => {\n    const {\n      useMoreAccuratePostalCode = false,\n      onError = () => null,\n      onConfirm = () => null\n    } = this.props;\n\n    const placeId = this.formattedPredictionsMap[value];\n    const selectedPrediction = this.predictions.find(\n      prediction => prediction.place_id === placeId\n    );\n\n    if (selectedPrediction !== undefined) {\n      try {\n        const placeResult = await this.getPlaceDetails(selectedPrediction);\n\n        if (\n          this.hasPartialPostalCode(placeResult.address_components) &&\n          useMoreAccuratePostalCode\n        ) {\n          const geocodeResult = await this.getReverseGeocodeData(placeResult);\n\n          // Remove Google Places postal code that may be a partial code.\n          placeResult.address_components = placeResult.address_components.filter(\n            component => !component.types.includes('postal_code')\n          );\n\n          // Add reverse geocode postal code value.\n          placeResult.address_components = placeResult.address_components.concat(\n            geocodeResult.address_components.filter(component =>\n              component.types.includes('postal_code')\n            )\n          );\n        }\n\n        if (\n          ['fl', 'rm'].includes(this.unitDesignator) &&\n          this.unitNumber !== ''\n        ) {\n          const designatorMap = {\n            fl: 'floor',\n            rm: 'room'\n          };\n\n          // If `room` or `floor` are parsed, add them to the address result the\n          // same way Google does.\n          placeResult.address_components.push({\n            long_name: this.unitNumber,\n            short_name: this.unitNumber,\n            types: [designatorMap[this.unitDesignator]]\n          });\n        } else {\n          // Add unit-number to address components if applicable. This is a\n          // custom field not returned by Google Places. See\n          // https://developers.google.com/maps/documentation/geocoding/intro#Types\n          if (this.unitNumber !== '') {\n            placeResult.address_components.push({\n              long_name: this.unitNumber,\n              short_name: this.unitNumber,\n              types: ['unit_number']\n            });\n          }\n\n          // Add unit-designator to address components if applicable. This is a\n          // custom field not returned by Google Places. See\n          // https://developers.google.com/maps/documentation/geocoding/intro#Types\n          if (this.unitDesignator !== '') {\n            placeResult.address_components.push({\n              long_name: this.unitDesignator,\n              short_name: this.unitDesignator,\n              types: ['unit_designator']\n            });\n          }\n        }\n\n        this.hasPlaceSelected = true;\n        this.placesSessionToken = new google.maps.places.AutocompleteSessionToken();\n\n        onConfirm(placeResult);\n      } catch (e) {\n        onError(e);\n      }\n    }\n  };\n\n  public onApiLoad() {\n    this.setState(() => ({ apiLoaded: true }));\n    this.autocompleteService = new google.maps.places.AutocompleteService();\n    this.geocoderService = new google.maps.Geocoder();\n    this.placesService = new google.maps.places.PlacesService(\n      document.createElement('div')\n    );\n    this.placesSessionToken = new google.maps.places.AutocompleteSessionToken();\n  }\n\n  public getNoResultsMessage(): string {\n    const { t = translate } = this.props;\n    return t('addressAutoComplete.noResults');\n  }\n\n  public getStatusSelectedOptionMessage(selectedOption: string): string {\n    const { t = translate } = this.props;\n    return t('addressAutoComplete.statusSelectedOption', {\n      option: selectedOption\n    });\n  }\n\n  public getStatusNoResultsMessage(): string {\n    const { t = translate } = this.props;\n    const statusNoResults = t('addressAutoComplete.statusNoResults');\n\n    // don't repeat \"No matching addresses\" over and over\n    if (this.currentStatusMessage === statusNoResults) {\n      return '';\n    }\n\n    this.currentStatusMessage = statusNoResults;\n    return statusNoResults;\n  }\n\n  public getStatusResultsMessage(\n    length: number,\n    contentSelectedOption: string\n  ): string {\n    const { t = translate } = this.props;\n\n    if (contentSelectedOption) {\n      return '';\n    }\n\n    const statusResults = t('addressAutoComplete.statusResults', {\n      smart_count: length\n    });\n\n    // don't repeat \"5 matching addresses\" over and over\n    if (this.currentStatusMessage === statusResults) {\n      return '';\n    }\n\n    this.currentStatusMessage = statusResults;\n    return statusResults;\n  }\n\n  public getSuggestions(query: string, populateResults: any): void {\n    const {\n      googlePlacesOptions = {},\n      minLength = DEFAULT_MIN_LENGTH,\n      onClear = () => null,\n      unitDesignators\n    } = this.props;\n\n    const { civicAddress, unitDesignator, unitNumber } = parseUnitNumber(\n      query,\n      unitDesignators\n    );\n\n    // After parsing the unit and designator, we need to check the minimum\n    // length again. This prevents sending empty strings to Google Places.\n    if (civicAddress.length < minLength) {\n      populateResults([]);\n      return;\n    }\n\n    const request: google.maps.places.AutocompletionRequest = {\n      ...googlePlacesOptions,\n      input: civicAddress,\n      sessionToken: this.placesSessionToken\n    };\n\n    const getPlaces = (\n      predictions: google.maps.places.AutocompletePrediction[],\n      status: google.maps.places.PlacesServiceStatus\n    ) => {\n      if (status !== google.maps.places.PlacesServiceStatus.OK) {\n        populateResults([]);\n        return;\n      }\n\n      this.predictions = predictions;\n      this.unitNumber = unitNumber;\n      this.unitDesignator = unitDesignator;\n      this.formattedPredictionsMap = predictions.reduce(\n        (accumulator, prediction) => {\n          const key = this.formatPrediction(\n            prediction.description,\n            unitDesignator,\n            unitNumber\n          );\n          return {\n            ...accumulator,\n            [key]: prediction.place_id\n          };\n        },\n        {}\n      );\n\n      const results = Object.keys(this.formattedPredictionsMap);\n      populateResults(results);\n    };\n\n    if (this.autocompleteService) {\n      this.autocompleteService.getPlacePredictions(request, getPlaces);\n    }\n\n    if (this.hasPlaceSelected) {\n      this.hasPlaceSelected = false;\n      onClear();\n    }\n  }\n\n  public render() {\n    const {\n      autoselect = false,\n      googlePlacesApiKey,\n      id,\n      minLength = DEFAULT_MIN_LENGTH,\n      required = false\n    } = this.props;\n    const { apiLoaded } = this.state;\n    const encodedKey = encodeURIComponent(googlePlacesApiKey);\n    const googlePlacesApi = `https://maps.googleapis.com/maps/api/js?key=${encodedKey}&libraries=places`;\n\n    return (\n      <div\n        aria-live=\"polite\"\n        style={{ visibility: apiLoaded ? 'visible' : 'hidden' }}\n      >\n        <Script url={googlePlacesApi} onLoad={this.onApiLoad} />\n        <Autocomplete\n          autoselect={autoselect}\n          id={id}\n          source={this.getSuggestions}\n          minLength={minLength}\n          required={required}\n          displayMenu=\"overlay\"\n          tNoResults={this.getNoResultsMessage}\n          tStatusSelectedOption={this.getStatusSelectedOptionMessage}\n          tStatusNoResults={this.getStatusNoResultsMessage}\n          tStatusResults={this.getStatusResultsMessage}\n          onConfirm={this.onAutoCompleteSelect}\n        />\n      </div>\n    );\n  }\n\n  private formatPrediction(\n    civicAddress: string,\n    unitDesignator: string,\n    unitNumber: string\n  ): string {\n    if (unitDesignator !== '') {\n      const unitAddress = `${unitDesignator} ${unitNumber}`;\n\n      // Insert unit number and designator after first comma\n      return civicAddress.replace(/,/, ` ${unitAddress},`);\n    }\n\n    if (unitNumber !== '') {\n      return `${unitNumber}-${civicAddress}`;\n    }\n\n    return civicAddress;\n  }\n\n  private hasPartialPostalCode(\n    addressComponents: google.maps.GeocoderAddressComponent[]\n  ): boolean {\n    return (\n      addressComponents.find(component =>\n        component.types.includes('postal_code_prefix')\n      ) !== undefined\n    );\n  }\n\n  private getPlaceDetails(\n    prediction: google.maps.places.AutocompletePrediction\n  ): Promise<google.maps.places.PlaceResult> {\n    if (this.placesService === undefined) {\n      return Promise.reject('Google places service is not available.');\n    }\n\n    return new Promise((resolve, reject) => {\n      this.placesService!.getDetails(\n        {\n          placeId: prediction.place_id,\n          sessionToken: this.placesSessionToken\n        },\n        (\n          placeResult: google.maps.places.PlaceResult,\n          requestStatus: google.maps.places.PlacesServiceStatus\n        ) => {\n          if (requestStatus === google.maps.places.PlacesServiceStatus.OK) {\n            resolve(placeResult);\n          } else {\n            reject(requestStatus);\n          }\n        }\n      );\n    });\n  }\n\n  private getReverseGeocodeData(\n    place: google.maps.places.PlaceResult\n  ): Promise<google.maps.GeocoderResult> {\n    if (this.geocoderService === undefined) {\n      return Promise.reject('Google geocoding service is not available.');\n    }\n\n    return new Promise((resolve, reject) => {\n      this.geocoderService!.geocode(\n        {\n          location: place.geometry.location\n        },\n        (\n          geocodeResult: google.maps.GeocoderResult[],\n          geocodeStatus: google.maps.GeocoderStatus\n        ) => {\n          if (geocodeStatus === google.maps.GeocoderStatus.OK) {\n            // Find first reverse geocode address that matches the street\n            // number, name, and city.\n            const bestResult = geocodeResult.find(result => {\n              // Match all the required fields for the reverse geocode address\n              // and reduce field matches to a single boolean value.\n              return ['street_number', 'route', 'locality']\n                .map(fieldName => {\n                  return (\n                    place.address_components[fieldName] ===\n                    result.address_components[fieldName]\n                  );\n                })\n                .reduce((isAddressMatch, isFieldMatch) => {\n                  return isAddressMatch && isFieldMatch;\n                }, true);\n            });\n\n            resolve(bestResult === undefined ? geocodeResult[0] : bestResult);\n          } else {\n            reject(geocodeStatus);\n          }\n        }\n      );\n    });\n  }\n}\n\nexport const DEFAULT_UNIT_DESIGNATORS = DEFAULT_DESIGNATORS;\n","module.exports = require(\"react\");","module.exports = require(\"react-load-script\");","module.exports = require(\"accessible-autocomplete/react\");","import * as get from 'get-value';\n\nexport function translate(message: string, context: any): string {\n  const messages = {\n    addressAutoComplete: {\n      noResults: 'Address not found',\n      statusNoResults: 'No matching addresses',\n      statusResults:\n        '%{smart_count} matching address is available |||| %{smart_count} matching addresses are available',\n      statusSelectedOption: 'You’ve selected %{option}'\n    }\n  };\n\n  let translation = get(messages, message);\n\n  if (!context) {\n    return translation;\n  }\n\n  if (!translation) {\n    return message;\n  }\n\n  // Support English plurals. More complex requirements should use an external\n  // i18n library like Polyglot.\n  if (context.smart_count !== undefined) {\n    const pluralForms = translation.split('||||');\n    const pluralIndex = context.smart_count === 1 ? 0 : 1;\n    translation = pluralForms[pluralIndex].trim();\n  }\n\n  // Interpolate results.\n  return translation.replace(\n    /%\\{(.*?)\\}/g,\n    (match: string, contextKey: string): string => {\n      if (context[contextKey] === undefined) {\n        return match;\n      }\n      if (typeof context[contextKey] === 'string') {\n        return context[contextKey].replace(/\\$/g, '$$');\n      }\n      return context[contextKey];\n    }\n  );\n}\n","module.exports = require(\"get-value\");","export interface IParseUnitNumberResult {\n  civicAddress: string;\n  unitDesignator: string;\n  unitNumber: string;\n}\n\n// Mapping of full unit designator string to preferred abbreviation. See\n// https://pe.usps.com/text/pub28/28apc_003.htm#ep538629 for a list of\n// supported unit number designators.\nexport const DEFAULT_DESIGNATORS = {\n  '#': '',\n  apartment: 'apt',\n  building: 'bldg',\n  department: 'dept',\n  floor: 'fl',\n  hanger: 'hngr',\n  key: 'key',\n  lot: 'lot',\n  pier: 'pier',\n  room: 'rm',\n  slip: 'slip',\n  space: 'spc',\n  stop: 'stop',\n  suite: 'ste',\n  trailer: 'trlr',\n  unit: 'unit'\n};\n\nfunction buildDesignatorExpression(unitDesignators: Record<string, string>) {\n  return Object.keys(unitDesignators)\n    .reduce((accumulator, current) => {\n      const value = unitDesignators[current];\n      if (value !== '' && value !== current) {\n        return [...accumulator, current, `${value}\\\\.?`];\n      }\n      return [...accumulator, current];\n    }, [])\n    .join('|');\n}\n\n// Matches Unit numbers that are all numbers, one letter, or numbers followed\n// by 1 letter.\nconst unitNumberExp = '[0-9]+(?:[\\\\s-]?[a-z])?|[a-z]';\n\n// Removes and space or dash separators from unit and returns in upper-case.\nfunction normalizeUnitNumber(unitNumber: string) {\n  return unitNumber.replace(/[ -]/g, '').toUpperCase();\n}\n\n// Removes any trailing . characters and normalizes to the preferred designator\n// abbreviation.\nfunction normalizeDesignator(\n  unitDesignators: Record<string, string>,\n  designator: string\n): string {\n  const strippedDesignator = designator.replace(/\\./, '').toLocaleLowerCase();\n\n  return unitDesignators[strippedDesignator] !== undefined\n    ? unitDesignators[strippedDesignator]\n    : strippedDesignator;\n}\n\nexport function parseUnitNumber(\n  query: string,\n  unitDesignators: Record<string, string> = DEFAULT_DESIGNATORS\n): IParseUnitNumberResult {\n  // Combine designators and abbreviated designators into regex string.\n  const designators = buildDesignatorExpression(unitDesignators);\n\n  // Match dashed address formats where the unit goes before the street number.\n  const dashedMatches = /^[\\s#]*([0-9]+(?:[\\s-]?[a-z])?|[a-z])[\\s-–\\/]+([0-9]+\\s.*)\\s*$/i.exec(\n    query\n  );\n  if (dashedMatches !== null) {\n    return {\n      civicAddress: dashedMatches[2],\n      unitDesignator: '',\n      unitNumber: dashedMatches[1].toUpperCase()\n    };\n  }\n\n  // Match dashed address formats where the unit is a letter after the street number.\n  const dashedLetterMatches = /^\\s*([0-9]+)[\\s-–\\/]*([a-z])\\s(.*)\\s*$/i.exec(\n    query\n  );\n  if (dashedLetterMatches !== null) {\n    return {\n      civicAddress: `${dashedLetterMatches[1]} ${dashedLetterMatches[3]}`,\n      unitDesignator: '',\n      unitNumber: dashedLetterMatches[2].toUpperCase()\n    };\n  }\n\n  // Match unit number and designator after the civic number and before the\n  // street name. Needs to go before after-street case to prevent parsing civic\n  // number as a full street address.\n  const afterNumber = new RegExp(\n    `^\\\\s*([0-9]+)\\\\s+(${designators})\\\\s*(${unitNumberExp})([\\\\s,].*)$`,\n    'i'\n  );\n  const afterNumberMatches = afterNumber.exec(query);\n  if (afterNumberMatches !== null) {\n    const unitDesignator = normalizeDesignator(\n      unitDesignators,\n      afterNumberMatches[2]\n    );\n    const unitNumber = normalizeUnitNumber(afterNumberMatches[3]);\n\n    return {\n      civicAddress: `${afterNumberMatches[1].replace(\n        /[\\s,]*$/,\n        ''\n      )} ${afterNumberMatches[4].replace(/^[\\s,]*/, '')}`,\n      unitDesignator,\n      unitNumber\n    };\n  }\n\n  // Match unit number and designator after the street address.\n  const afterStreet = new RegExp(\n    `^\\\\s*([0-9]+.+)\\\\s(${designators})\\\\s*(${unitNumberExp})([\\\\s,].*|$)$`,\n    'i'\n  );\n  const afterStreetMatches = afterStreet.exec(query);\n  if (afterStreetMatches !== null) {\n    const unitDesignator = normalizeDesignator(\n      unitDesignators,\n      afterStreetMatches[2]\n    );\n    const unitNumber = normalizeUnitNumber(afterStreetMatches[3]);\n    const civicAddressPart1 = afterStreetMatches[1].replace(/[\\s,]*$/, '');\n    const civicAddressPart2 = afterStreetMatches[4].replace(/^[\\s,]*/, '');\n    const civicAddress = civicAddressPart2\n      ? `${civicAddressPart1}, ${civicAddressPart2}`\n      : civicAddressPart1;\n\n    return {\n      civicAddress,\n      unitDesignator,\n      unitNumber\n    };\n  }\n\n  // Match unit number and designator before the civic number.\n  const beforeCivicNumber = new RegExp(\n    `^\\\\s*(${designators})\\\\s*(${unitNumberExp})[-\\\\s,]+(.*)$`,\n    'i'\n  );\n  const beforeCivicNumberMatches = beforeCivicNumber.exec(query);\n  if (beforeCivicNumberMatches !== null) {\n    const unitDesignator = normalizeDesignator(\n      unitDesignators,\n      beforeCivicNumberMatches[1]\n    );\n    const unitNumber = normalizeUnitNumber(beforeCivicNumberMatches[2]);\n    return {\n      civicAddress: beforeCivicNumberMatches[3].replace(/^\\s*/, ''),\n      unitDesignator,\n      unitNumber\n    };\n  }\n\n  // No unit number was parsed in the given address.\n  return {\n    civicAddress: query,\n    unitDesignator: '',\n    unitNumber: ''\n  };\n}\n"],"sourceRoot":""}